<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>David Raab</title>
    <link>https://davidraab.github.io/</link>
    <description>Recent content on David Raab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://davidraab.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Closures in F#, C#, Perl, JavaScript and Racket</title>
      <link>https://davidraab.github.io/posts/closures-in-fsharp-csharp-perl-javascript-and-racket/</link>
      <pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/closures-in-fsharp-csharp-perl-javascript-and-racket/</guid>
      <description>Today, more and more languages supports functions as first-class values. This means a function is just a value like any other. You can pass functions as arguments to functions, but you are also able to create functions and return them from functions.
Whenever this is done we have to think about the life-time of variables. Usually all variables are lexical scoped. Consider the following example.
F# C# Perl JavaScript Racket 1 2 3 let add10 y = let x = 10 x + y 1 2 3 4 public static int Add10(int y) { var x = 10; return x + y; } 1 2 3 4 sub add10($y) { my $x = 10; return $x + $y; } 1 2 3 4 function add10(y) { const x = 10; return x + y; } 1 2 3 4 (define (add10 y) (define x 10) (+ x y) ) In the example the variable x is created only temporary when the function is being executed.</description>
    </item>
    
    <item>
      <title>What is Dependency injection?</title>
      <link>https://davidraab.github.io/posts/what-is-dependency-injection/</link>
      <pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/what-is-dependency-injection/</guid>
      <description>On Reddit i came to a question about someone who had problems understanding Dependency Injection. He provided the following code.
1 2 3 4 5 6 7 8 9 10 11 12 public class Wheel { public Wheel() {} public void moveleft() {} } public class Car { private Wheel wheel; public Car (Wheel wheel) { this.wheel = wheel; } } The question is: Is this usage of Wheel in Car Dependency injection?</description>
    </item>
    
    <item>
      <title>Perl Regex Parsing with the g option</title>
      <link>https://davidraab.github.io/posts/perl-regex-parsing-with-g-option/</link>
      <pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/perl-regex-parsing-with-g-option/</guid>
      <description>Perl regexes have the /g modifier that is worth knowing about, as you can do a lot of advanced things with this modifier. But here are the basics first.
Context First we need to understand that Perl has two different contexts and in both contexts the /g modifier works differently.
List context Let&amp;rsquo;s see list context first. We can enforce list context by assigning to an array.
Without the /g option a regex just finds its first match and just returns it.</description>
    </item>
    
    <item>
      <title>Are dynamic-typed languages really faster to develop in?</title>
      <link>https://davidraab.github.io/posts/are-dynamic-typed-languages-really-faster-to-develop/</link>
      <pubDate>Fri, 02 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/are-dynamic-typed-languages-really-faster-to-develop/</guid>
      <description>On Reddit i came about a discussion of dynamic typed (functional) languages. A user suggested that in a dynamic typed language it might be easier to return different types for a function call and thus overall the development can be faster. He concluded.
Having not to deal with types in that way when you refactor or build a system makes you significantly faster. Combine that with a proper testing approach and you have a reason to use dynamically typed languages.</description>
    </item>
    
    <item>
      <title>Map operates on functions!</title>
      <link>https://davidraab.github.io/posts/map-operates-on-functions/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/map-operates-on-functions/</guid>
      <description>map operates on functions not on data-types like list.
When I started learning F# I had some problems understanding the map function. Don&amp;rsquo;t get me wrong. As a Perl programmer map is built into the core language (long before other languages adopted the idea) and I used and understanded it very well in Perl. This map is the same as List.map that I also immediately understood.
But in F# you will encounter Result.</description>
    </item>
    
    <item>
      <title>Optional Generic Equality on a Data-Type in F#</title>
      <link>https://davidraab.github.io/posts/optional-generic-equality/</link>
      <pubDate>Tue, 25 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/optional-generic-equality/</guid>
      <description>Lately I implemented my own immutable Queue and came upon a problem implementing equality for it. The problem goes like this: You want a generic data-type that supports equality. But it only should support equality if the generic type also supports equality.
Seems a little bit weird? But this is actually a common problem in F# that is already solved without that you probably even noticed that this is a problem.</description>
    </item>
    
    <item>
      <title>Understanding Fold</title>
      <link>https://davidraab.github.io/posts/understanding-fold/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/understanding-fold/</guid>
      <description>A very important function in List-processing is the List.fold function. List.fold is a very powerful function that gives you a lot of flexibility to do any kind of list transformation. The disadvantage is that this kind of power makes understanding List.fold a lot harder. In this article we look at some visualizations to better understand List.fold.
First we need to understand how we visualize a function. A function has some inputs and one output and we visualize it as a box with the inputs on the top and the output on the bottom.</description>
    </item>
    
    <item>
      <title>Variable Arguments in F#</title>
      <link>https://davidraab.github.io/posts/variable-arguments-in-fsharp/</link>
      <pubDate>Mon, 13 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/variable-arguments-in-fsharp/</guid>
      <description>One question that appears in F# from time to time is: How do you create a function that expects a variable amount of arguments?
A short answer is: You can&amp;rsquo;t do that.
A longer and correct answer: You can do it with (static) methods. But you probably don&amp;rsquo;t want to use this and look for an alternative.
First we should look at the difference between an F# function and a (static) method.</description>
    </item>
    
    <item>
      <title>Mutability vs. Immutability: Valid objects</title>
      <link>https://davidraab.github.io/posts/mutabaility-vs-immutability-validation/</link>
      <pubDate>Mon, 27 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/mutabaility-vs-immutability-validation/</guid>
      <description>I already wrote an article that explains immutability, but one thing I hand-waved was the benefits of immutability and why you should program with immutable values.
In this article I talk about those benefits by trying to maintaining valid objects at all time and show how we can achieve it with mutability and immutability.
One question might be why I&amp;rsquo;m not just showing the immutable part. I could do this, but the problem I see is that it isn&amp;rsquo;t so obvious how hard the mutable part really is.</description>
    </item>
    
    <item>
      <title>Function Application and Composition</title>
      <link>https://davidraab.github.io/posts/function-application-and-composition/</link>
      <pubDate>Sun, 25 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/function-application-and-composition/</guid>
      <description>Function application is probably one of those terms in functional programming that sounds more scarier as the topic really is. The idea behind functional application just means that we execute a function to get the result. Let&amp;rsquo;s take the example of calculating the square root of 2.0. We can write the following in F# to do that:
1 let x = sqrt 2.0 The interesting part is how we read this example.</description>
    </item>
    
    <item>
      <title>Catamorphisms</title>
      <link>https://davidraab.github.io/posts/catamorphisms/</link>
      <pubDate>Sat, 28 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/catamorphisms/</guid>
      <description>Up to this point I created various articles about fold, in my Series I also created a category named Fold (Catamorphisms) but up till now I didn&amp;rsquo;t explained how this articles related to each other, or what Catamorphisms mean. In this article I want to talk about the remaining parts.
The List Catamorphisms is a generalization that emerged from the list data-structure. The list data-structure, how it is found in functional programming, is usually build as a single linked list.</description>
    </item>
    
    <item>
      <title>Monoids</title>
      <link>https://davidraab.github.io/posts/monoids/</link>
      <pubDate>Tue, 24 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/monoids/</guid>
      <description>A monoid is a simple concept. It is a generalization of some patterns that you very likely already have seen. Being aware of those can help in designing some operations and can simplify things. Without much further ado let us look at three simple math equations.
1 + 2 = 3 (1 + 2) + 3 = 1 + (2 + 3) 1 + 0 = 0 + 1 Table of Content Binary Operations Associativity Identity Monoids Subtraction Multiplication Division What is the purpose of all of this?</description>
    </item>
    
    <item>
      <title>Introduction to Functional Programming</title>
      <link>https://davidraab.github.io/posts/introduction-to-functional-programming/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/introduction-to-functional-programming/</guid>
      <description>In this article I want to give a general introduction to some of the fundamental ideas of functional programming. I just start with the idea of function as data, and explain why functions are viewed as data and why it makes sense to pass functions as arguments.
When we understand this concept, I start explaining lambda expression, currying, partial application and closures. All of this ideas built on each other.</description>
    </item>
    
    <item>
      <title>The Option Module</title>
      <link>https://davidraab.github.io/posts/option-module/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/option-module/</guid>
      <description>The Option type is a well known and often used type, but at least for me, most of the time I just used Option.map and Option.bind and ignored functions like Option.exists, Option.filter, Option.fold and so on. I spent some time with those functions to understand when those are useful.
defaultArg The first function i look at is actually not in the Option module. It is the defaultArg function. With defaultArg we can extract an option type and provide a default value in the case we had no value.</description>
    </item>
    
    <item>
      <title>CPS fold -- fold with early exit</title>
      <link>https://davidraab.github.io/posts/cps-fold/</link>
      <pubDate>Sat, 07 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/cps-fold/</guid>
      <description>The most general function to traverse a data-structures is the fold function. But fold has one problem that is sometimes not optimal. It always traverses the whole data-structure and we cannot abort the recusion early.
But sometimes, that is exactly what we want to do. For example when we want to search for a specific element in a list, when we found it, we don&amp;rsquo;t want to go through the remaing list.</description>
    </item>
    
    <item>
      <title>Algebraic Data-Types</title>
      <link>https://davidraab.github.io/posts/algebraic-data-types/</link>
      <pubDate>Tue, 26 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/algebraic-data-types/</guid>
      <description>When we work in a programming language we usually have some primitive data-types likes int, float, string, bool and so on. All of those are important, but when we need to create more advanced logic we usually want to create our own data-types and group/compose different types together to create new data-types.
In an algebraic type-system there exists two different ways in how we can compose types. They are named Product-types and Sum-type.</description>
    </item>
    
    <item>
      <title>Continuations and foldBack</title>
      <link>https://davidraab.github.io/posts/continuations-and-foldback/</link>
      <pubDate>Sat, 16 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/continuations-and-foldback/</guid>
      <description>In From mutable loops to immutable folds we implemented foldBack through rev and fold. In this post I show you how you can implement foldBack by using a continuation function.
Functions Before we see how to implement foldBack, I want to give you analogy first. This analogy helped me in a lot of cases. I hope that this analogy will also help you in better understanding the further post, or probably even in other areas in programming in general.</description>
    </item>
    
    <item>
      <title>Sequence and Traverse</title>
      <link>https://davidraab.github.io/posts/sequence-and-traverse/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/sequence-and-traverse/</guid>
      <description>One problem that appears from time to time is that we we have some kind of collection (I use list here) and we want to map every element with a monadic function &#39;a -&amp;gt; M&amp;lt;&#39;b&amp;gt;. This then returns a list&amp;lt;M&amp;lt;&#39;a&amp;gt;&amp;gt;. But often we want a M&amp;lt;list&amp;lt;&#39;a&amp;gt;&amp;gt;.
To be more concrete. Let&amp;rsquo;s assume we want to turn a list of strings into integers. We could write a tryParseInt function that does string -&amp;gt; option&amp;lt;int&amp;gt;.</description>
    </item>
    
    <item>
      <title>Applicative: Lists</title>
      <link>https://davidraab.github.io/posts/applicative-list/</link>
      <pubDate>Wed, 13 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applicative-list/</guid>
      <description>In Applicative Functors I primarily used the Option type to show how you implement and use an Applicative Functor. But the concept also works for any other type. This time I want to show you the idea of an Applicative with a list, what it means, what you can do with it and how apply works.
Implementing apply Currently the List module don&amp;rsquo;t offer a apply function. So we must write it on our own.</description>
    </item>
    
    <item>
      <title>Optionals</title>
      <link>https://davidraab.github.io/posts/optionals-app/</link>
      <pubDate>Mon, 11 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/optionals-app/</guid>
      <description>In this post I want to talk about Optionals more deeply. I already wrote about null, but I noticed that it is still not immediately clear on why Optionals are better. Instead of focusing why null is bad, this time I want to focus why Optionals are good. For this purpose I also wrote a small application that I will cover. But first, let&amp;rsquo;s go over Optionals and see which benefits they have.</description>
    </item>
    
    <item>
      <title>From mutable loops to immutable folds</title>
      <link>https://davidraab.github.io/posts/loops-to-folds/</link>
      <pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/loops-to-folds/</guid>
      <description>When we ask of key-features of functional programming, you will probably hear two things most often. Immutability and recursion. But why is that so? As Immutability also becomes more important in OO languages you will probably find a lot of reason for that one, but why are recursive functions so important? The short answer is, because of Immutability! To understand the connection between those, let&amp;rsquo;s start with some code that uses loops with mutation.</description>
    </item>
    
    <item>
      <title>Understanding bind</title>
      <link>https://davidraab.github.io/posts/understanding-bind/</link>
      <pubDate>Sun, 03 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/understanding-bind/</guid>
      <description>In Understanding map we learned that implementing a map function is what we call a Functor. In Applicative Functors we extended that idea with the return and apply function and we call the result an Applicative Functor. The next important function in our toolset is the bind function.
Monads The combination of return and bind is what we call a Monad. But currently I will not consider this as an introduction to Monads at all.</description>
    </item>
    
    <item>
      <title>Applicative Functors</title>
      <link>https://davidraab.github.io/posts/applicative-functors/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applicative-functors/</guid>
      <description>In my previous article Understanding map I introduced the map function and described that implementing map and fulfilling two laws we get what we call a Functor. In this Post we discuss the apply function that we can view as an extension to the map function.
Problem with map It might be that you have noticed one problem with map. map only can work with one-argument functions! The definition of map expects a function &#39;a -&amp;gt; &#39;b as it&amp;rsquo;s first argument.</description>
    </item>
    
    <item>
      <title>Understanding map</title>
      <link>https://davidraab.github.io/posts/understanding-map/</link>
      <pubDate>Sun, 27 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/understanding-map/</guid>
      <description>One important function in functional programming is the map function. When I learned F# I must admit that I had some problems first, understanding it. The problem was, I already knew the map function from dozens of other languages. Or to say it correctly, I mostly learned a wrong explanation of map.
The typical explanation I&amp;rsquo;m talking about often goes something like this: map takes a function and a list. It applies the function to every element in the list, and returns a new list.</description>
    </item>
    
    <item>
      <title>Exceptions are Evil</title>
      <link>https://davidraab.github.io/posts/exceptions-are-evil/</link>
      <pubDate>Fri, 25 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/exceptions-are-evil/</guid>
      <description>Most people today agree that null is evil, and they try to get rid of them. One technique that most people prefer is to throw an exception in the case of an error, or if we cannot return a valid value from a function. The problem is, exceptions are not any kind better than null, and they don&amp;rsquo;t solve any problem that null introduced.
In my previous post null is Evil i mentioned seven problems that null introduced.</description>
    </item>
    
    <item>
      <title>Higher-kinded Polymorphism: What is it, why you want it</title>
      <link>https://davidraab.github.io/posts/higher-kinded-polymorphism/</link>
      <pubDate>Thu, 24 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/higher-kinded-polymorphism/</guid>
      <description>One aspect of a programming language that is often noted as important is the idea of Polymorphism. But there doesn&amp;rsquo;t exists just one type of polymorphism. In functional languages Parametric Polymorphism (aka Generics) is often used. Haskell was the first language that introduced &amp;ldquo;Higher-kinded polymorphism&amp;rdquo;. Sadly, F# don&amp;rsquo;t support this kind of polymorphism directly. Actually it only has partial support for it. So let&amp;rsquo;s look in what it is, and why you want it.</description>
    </item>
    
    <item>
      <title>null is Evil</title>
      <link>https://davidraab.github.io/posts/null-is-evil/</link>
      <pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/null-is-evil/</guid>
      <description>Tony Hoare once said: I call it my billion-dollar mistake. It was the invention of the null reference in 1965. So, why did he added &amp;ldquo;null&amp;rdquo; in the first place? Why was it such a big mistake. And if it is such a big mistake, what are the alternatives?
The purpose of null To understand why it was a mistake, let&amp;rsquo;s look why it was even added in the first place.</description>
    </item>
    
    <item>
      <title>Understanding Immutability and Pure Functions (for OOP)</title>
      <link>https://davidraab.github.io/posts/immutability-and-functions/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/immutability-and-functions/</guid>
      <description>One important concept in functional programming is immutability. But also in object-oriented programming immutability and so called immutable objects getting more attention. The problem that I see especially from object-oriented programmers are really bad explanations. A lot of explanation I had see described it like this: Just create a class and make all fields readonly (final or const) and you have an immutable object.
Explanations like these are horrible. Such explanations are so simplified that I would even call them wrong.</description>
    </item>
    
    <item>
      <title>Introduction to F#</title>
      <link>https://davidraab.github.io/posts/introduction-fsharp/</link>
      <pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/introduction-fsharp/</guid>
      <description>When I remember the first time I looked at functional(-first) languages like F#, ML, Haskell and others. The typical reaction that I had, and I always see from other people is: This is unreadable, it must be hard to read, it feels complicated and hard.
After spending some time in F# I cannot agree to that at all anymore. Often the syntax itself is easier (for example compared to C#), shorter and in my opinion more readable.</description>
    </item>
    
    <item>
      <title>Applying Structured Programming</title>
      <link>https://davidraab.github.io/posts/applying-structured-programming/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applying-structured-programming/</guid>
      <description>In my previous post about Structured Programming I talked about that basic looping constructs fold. But this is still to powerful. In the sense of readability we should try to eliminate them with more specific ones. In this post I go through a toy example to show the various ways on how to refactor some code.
The Toy Example Recently I had some conversation about code in a game and providing some kind of critical hit-chance in a game.</description>
    </item>
    
    <item>
      <title>Structured Programming</title>
      <link>https://davidraab.github.io/posts/structured-programming/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/structured-programming/</guid>
      <description>Back in 1968 Edsger W. Dijkstra wrote an open letter named &amp;ldquo;Go To Statement Considered Harmful&amp;rdquo;. As already suggested from the title, the very idea was to raise consciousness that the goto statement is more harmful then helpful. From today view we would expect that this idea catches fire really fast, but it didn&amp;rsquo;t. It took quite a long time. Even during all the 1970s and 1980s that question was debated a lot.</description>
    </item>
    
  </channel>
</rss>
