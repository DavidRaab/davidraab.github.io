<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>David Raab</title>
    <link>https://davidraab.github.io/</link>
    <description>Recent content on David Raab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 May 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://davidraab.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Option Module</title>
      <link>https://davidraab.github.io/posts/option-module/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/option-module/</guid>
      <description>The Option type is a well known and often used type, but at least for me, most of the time I just used Option.map and Option.bind and ignored functions like Option.exists, Option.filter, Option.fold and so on. I spent some time with those functions to understand when those are useful.
defaultArg The first function i look at is actually not in the Option module. It is the defaultArg function. With defaultArg we can extract an option type and provide a default value in the case we had no value.</description>
    </item>
    
    <item>
      <title>CPS fold -- fold with early exit</title>
      <link>https://davidraab.github.io/posts/cps-fold/</link>
      <pubDate>Sat, 07 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/cps-fold/</guid>
      <description>The most general function to traverse a data-structures is the fold function. But fold has one problem that is sometimes not optimal. It always traverses the whole data-structure and we cannot abort the recusion early.
But sometimes, that is exactly what we want to do. For example when we want to search for a specific element in a list, when we found it, we don&amp;rsquo;t want to go through the remaing list.</description>
    </item>
    
    <item>
      <title>Algebraic Data-Types</title>
      <link>https://davidraab.github.io/posts/algebraic-data-types/</link>
      <pubDate>Tue, 26 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/algebraic-data-types/</guid>
      <description>When we work in a programming language we usually have some primitive data-types likes int, float, string, bool and so on. All of those are important, but when we need to create more advanced logic we usually want to create our own data-types and group/compose different types together to create new data-types.
In an algebraic type-system there exists two different ways in how we can compose types. They are named Product-types and Sum-type.</description>
    </item>
    
    <item>
      <title>Continuations and foldBack</title>
      <link>https://davidraab.github.io/posts/continuations-and-foldback/</link>
      <pubDate>Sat, 16 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/continuations-and-foldback/</guid>
      <description>In From mutable loops to immutable folds we implemented foldBack through rev and fold. In this post I show you how you can implement foldBack by using a continuation function.
Functions Before we see how to implement foldBack, I want to give you analogy first. This analogy helped me in a lot of cases. I hope that this analogy will also help you in better understanding the further post, or probably even in other areas in programming in general.</description>
    </item>
    
    <item>
      <title>Sequence and Traverse</title>
      <link>https://davidraab.github.io/posts/sequence-and-traverse/</link>
      <pubDate>Thu, 14 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/sequence-and-traverse/</guid>
      <description>One problem that appears from time to time is that we we have some kind of collection (I use list here) and we want to map every element with a monadic function &#39;a -&amp;gt; M&amp;lt;&#39;b&amp;gt;. This then returns a list&amp;lt;M&amp;lt;&#39;a&amp;gt;&amp;gt;. But often we want a M&amp;lt;list&amp;lt;&#39;a&amp;gt;&amp;gt;.
To be more concrete. Let&amp;rsquo;s assume we want to turn a list of strings into integers. We could write a tryParseInt function that does string -&amp;gt; option&amp;lt;int&amp;gt;.</description>
    </item>
    
    <item>
      <title>Applicative: Lists</title>
      <link>https://davidraab.github.io/posts/applicative-list/</link>
      <pubDate>Wed, 13 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applicative-list/</guid>
      <description>In Applicative Functors I primarily used the Option type to show how you implement and use an Applicative Functor. But the concept also works for any other type. This time I want to show you the idea of an Applicative with a list, what it means, what you can do with it and how apply works.
Implementing apply Currently the List module don&amp;rsquo;t offer a apply function. So we must write it on our own.</description>
    </item>
    
    <item>
      <title>Optionals</title>
      <link>https://davidraab.github.io/posts/optionals-app/</link>
      <pubDate>Mon, 11 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/optionals-app/</guid>
      <description>In this post I want to talk about Optionals more deeply. I already wrote about null, but I noticed that it is still not immediately clear on why Optionals are better. Instead of focusing why null is bad, this time I want to focus why Optionals are good. For this purpose I also wrote a small application that I will cover. But first, let&amp;rsquo;s go over Optionals and see which benefits they have.</description>
    </item>
    
    <item>
      <title>From mutable loops to immutable folds</title>
      <link>https://davidraab.github.io/posts/loops-to-folds/</link>
      <pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/loops-to-folds/</guid>
      <description>When we ask of key-features of functional programming, you will probably hear two things most often. Immutability and recursion. But why is that so? As Immutability also becomes more important in OO languages you will probably find a lot of reason for that one, but why are recursive functions so important? The short answer is, because of Immutability! To understand the connection between those, let&amp;rsquo;s start with some code that uses loops with mutation.</description>
    </item>
    
    <item>
      <title>Understanding bind</title>
      <link>https://davidraab.github.io/posts/understanding-bind/</link>
      <pubDate>Sun, 03 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/understanding-bind/</guid>
      <description>In Understanding map we learned that implementing a map function is what we call a Functor. In Applicative Functors we extended that idea with the return and apply function and we call the result an Applicative Functor. The next important function in our toolset is the bind function.
Monads The combination of return and bind is what we call a Monad. But currently I will not consider this as an introduction to Monads at all.</description>
    </item>
    
    <item>
      <title>Applicative Functors</title>
      <link>https://davidraab.github.io/posts/applicative-functors/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applicative-functors/</guid>
      <description>In my previous article Understanding map I introduced the map function and described that implementing map and fulfilling two laws we get what we call a Functor. In this Post we discuss the apply function that we can view as an extension to the map function.
Problem with map It might be that you have noticed one problem with map. map only can work with one-argument functions! The definition of map expects a function &#39;a -&amp;gt; &#39;b as it&amp;rsquo;s first argument.</description>
    </item>
    
    <item>
      <title>Understanding map</title>
      <link>https://davidraab.github.io/posts/understanding-map/</link>
      <pubDate>Sun, 27 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/understanding-map/</guid>
      <description>One important function in functional programming is the map function. When I learned F# I must admit that I had some problems first, understanding it. The problem was, I already knew the map function from dozens of other languages. Or to say it correctly, I mostly learned a wrong explanation of map.
The typical explanation I&amp;rsquo;m talking about often goes something like this: map takes a function and a list. It applies the function to every element in the list, and returns a new list.</description>
    </item>
    
    <item>
      <title>Exceptions are Evil</title>
      <link>https://davidraab.github.io/posts/exceptions-are-evil/</link>
      <pubDate>Fri, 25 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/exceptions-are-evil/</guid>
      <description>Most people today agree that null is evil, and they try to get rid of them. One technique that most people prefer is to throw an exception in the case of an error, or if we cannot return a valid value from a function. The problem is, exceptions are not any kind better than null, and they don&amp;rsquo;t solve any problem that null introduced.
In my previous post null is Evil i mentioned seven problems that null introduced.</description>
    </item>
    
    <item>
      <title>Higher-kinded Polymorphism: What is it, why you want it</title>
      <link>https://davidraab.github.io/posts/higher-kinded-polymorphism/</link>
      <pubDate>Thu, 24 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/higher-kinded-polymorphism/</guid>
      <description>One aspect of a programming language that is often noted as important is the idea of Polymorphism. But there doesn&amp;rsquo;t exists just one type of polymorphism. In functional languages Parametric Polymorphism (aka Generics) is often used. Haskell was the first language that introduced &amp;ldquo;Higher-kinded polymorphism&amp;rdquo;. Sadly, F# don&amp;rsquo;t support this kind of polymorphism directly. Actually it only has partial support for it. So let&amp;rsquo;s look in what it is, and why you want it.</description>
    </item>
    
    <item>
      <title>null is Evil</title>
      <link>https://davidraab.github.io/posts/null-is-evil/</link>
      <pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/null-is-evil/</guid>
      <description>Tony Hoare once said: I call it my billion-dollar mistake. It was the invention of the null reference in 1965. So, why did he added &amp;ldquo;null&amp;rdquo; in the first place? Why was it such a big mistake. And if it is such a big mistake, what are the alternatives?
The purpose of null To understand why it was a mistake, let&amp;rsquo;s look why it was even added in the first place.</description>
    </item>
    
    <item>
      <title>Understanding Immutability and Pure Functions (for OOP)</title>
      <link>https://davidraab.github.io/posts/immutability-and-functions/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/immutability-and-functions/</guid>
      <description>One important concept in functional programming is immutability. But also in object-oriented programming immutability and so called immutable objects getting more attention. The problem that I see especially from object-oriented programmers are really bad explanations. A lot of explanation I had see described it like this: Just create a class and make all fields readonly (final or const) and you have an immutable object.
Explanations like these are horrible. Such explanations are so simplified that I would even call them wrong.</description>
    </item>
    
    <item>
      <title>Introduction to F#</title>
      <link>https://davidraab.github.io/posts/introduction-fsharp/</link>
      <pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/introduction-fsharp/</guid>
      <description>When I remember the first time I looked at functional(-first) languages like F#, ML, Haskell and others. The typical reaction that I had, and I always see from other people is: This is unreadable, it must be hard to read, it feels complicated and hard.
After spending some time in F# I cannot agree to that at all anymore. Often the syntax itself is easier (for example compared to C#), shorter and in my opinion more readable.</description>
    </item>
    
    <item>
      <title>Applying Structured Programming</title>
      <link>https://davidraab.github.io/posts/applying-structured-programming/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applying-structured-programming/</guid>
      <description>In my previous post about Structured Programming I talked about that basic looping constructs fold. But this is still to powerful. In the sense of readability we should try to eliminate them with more specific ones. In this post I go through a toy example to show the various ways on how to refactor some code.
The Toy Example Recently I had some conversation about code in a game and providing some kind of critical hit-chance in a game.</description>
    </item>
    
    <item>
      <title>Structured Programming</title>
      <link>https://davidraab.github.io/posts/structured-programming/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/structured-programming/</guid>
      <description>Back in 1968 Edsger W. Dijkstra wrote an open letter named &amp;ldquo;Go To Statement Considered Harmful&amp;rdquo;. As already suggested from the title, the very idea was to raise consciousness that the goto statement is more harmful then helpful. From today view we would expect that this idea catches fire really fast, but it didn&amp;rsquo;t. It took quite a long time. Even during all the 1970s and 1980s that question was debated a lot.</description>
    </item>
    
  </channel>
</rss>
