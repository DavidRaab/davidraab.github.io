<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>perl on David Raab</title>
    <link>https://davidraab.github.io/tags/perl/</link>
    <description>Recent content in perl on David Raab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 26 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://davidraab.github.io/tags/perl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Meta-Programming in Perl</title>
      <link>https://davidraab.github.io/posts/meta-programming-in-perl/</link>
      <pubDate>Thu, 26 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/meta-programming-in-perl/</guid>
      <description>In my last article about Special Values in Perl I explained how we can create true distinct values that can be safely distinguished by other values. The final result looked like this:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use Scalar::Util qw(refaddr reftype); # Special values Red, Green and Blue { # &amp;lt;-- this creates a new lexical-scope my ($red, $green, $blue) = ([], [], []); sub red { $red } sub green { $green } sub blue { $blue } my $is_color = sub { my ($source, $color) = @_; my $type = reftype($source) // &amp;#39;&amp;#39;; return ( $type eq &amp;#39;ARRAY&amp;#39; and refaddr($source) == refaddr($color) ) ?</description>
    </item>
    
    <item>
      <title>Special values in Perl</title>
      <link>https://davidraab.github.io/posts/special-values-in-perl/</link>
      <pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/special-values-in-perl/</guid>
      <description>Sometimes in programming we want to create special values that are distinct to anything else. Consider the following problem. We want to create a print_colored function, that can be given special values to change the terminal color. Here is one way to do it:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use Term::ANSIColor qw(color); my $red = &amp;#34;RED&amp;#34;; my $green = &amp;#34;GREEN&amp;#34;; my $blue = &amp;#34;BLUE&amp;#34;; sub print_colored { for my $line ( @_ ) { print(color(&amp;#39;red&amp;#39;)) &amp;amp;&amp;amp; next if $line eq $red; print(color(&amp;#39;green&amp;#39;)) &amp;amp;&amp;amp; next if $line eq $green; print(color(&amp;#39;blue&amp;#39;)) &amp;amp;&amp;amp; next if $line eq $blue; print $line; } } print_colored($green, &amp;#34;red&amp;#34;, &amp;#34;\n&amp;#34;, $blue, &amp;#34;foo\n&amp;#34;); This solution successfully prints the string &amp;ldquo;red&amp;rdquo; in the green color and &amp;ldquo;foo&amp;rdquo; in the blue color.</description>
    </item>
    
    <item>
      <title>Perl vs. JavaScript: Scalar and List Context</title>
      <link>https://davidraab.github.io/posts/perl-vs-javascript-scalar-and-list-context/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/perl-vs-javascript-scalar-and-list-context/</guid>
      <description>Something I like in Perl, and also dislike sometimes, is Perl distinction between Scalar- and List Context. Something I haven&amp;rsquo;t seen in any other language so far. In Perl any function call can happen in two different context. And depending on the context a function can return different things, or even behave differently. But it also effects how arguments are passed to a function.
Let&amp;rsquo;s see an example. I want to write an easy sum function that sums up all numbers given to it.</description>
    </item>
    
    <item>
      <title>Installing perl with perlbrew</title>
      <link>https://davidraab.github.io/posts/installing-perl-with-perlbrew/</link>
      <pubDate>Fri, 17 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/installing-perl-with-perlbrew/</guid>
      <description>Today every Linux system mostly already ships Perl including a lot of modules. While this can be totally fine sometimes maybe you want to switch to a newer Perl version. Or maybe even an older version to test a module with an older Perl version for compatibility?
perlbrew is a tool that helps installing multiple Perl environments and gives you the ability to switch between them. Installing your own Perl also means you don&amp;rsquo;t mess with the system installed Perl and you are able to install any new module directly from CPAN.</description>
    </item>
    
    <item>
      <title>Closures in F#, C#, Perl, JavaScript and Racket</title>
      <link>https://davidraab.github.io/posts/closures-in-fsharp-csharp-perl-javascript-and-racket/</link>
      <pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/closures-in-fsharp-csharp-perl-javascript-and-racket/</guid>
      <description>Today, more and more languages supports functions as first-class values. This means a function is just a value like any other. You can pass functions as arguments to functions, but you are also able to create functions and return them from functions.
Whenever this is done we have to think about the life-time of variables. Usually all variables are lexical scoped. Consider the following example.
F# C# Perl JavaScript Racket 1 2 3 let add10 y = let x = 10 x + y 1 2 3 4 public static int Add10(int y) { var x = 10; return x + y; } 1 2 3 4 sub add10($y) { my $x = 10; return $x + $y; } 1 2 3 4 function add10(y) { const x = 10; return x + y; } 1 2 3 4 (define (add10 y) (define x 10) (+ x y) ) In the example the variable x is created only temporary when the function is being executed.</description>
    </item>
    
    <item>
      <title>Perl Regex Parsing with the g option</title>
      <link>https://davidraab.github.io/posts/perl-regex-parsing-with-g-option/</link>
      <pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/perl-regex-parsing-with-g-option/</guid>
      <description>Perl regexes have the /g modifier that is worth knowing about, as you can do a lot of advanced things with this modifier. But here are the basics first.
Context First we need to understand that Perl has two different contexts and in both contexts the /g modifier works differently.
List context Let&amp;rsquo;s see list context first. We can enforce list context by assigning to an array.
Without the /g option a regex just finds its first match and just returns it.</description>
    </item>
    
  </channel>
</rss>
