<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on David Raab</title>
    <link>https://davidraab.github.io/posts/</link>
    <description>Recent content in Posts on David Raab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Apr 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://davidraab.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>From mutable loops to immutable folds</title>
      <link>https://davidraab.github.io/posts/loops-to-folds/</link>
      <pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/loops-to-folds/</guid>
      <description>When we ask of key-features of functional programming, you will probably hear two things most often. Immutability and recursion. But why is that so? As Immutability also becomes more important in OO languages you will probably find a lot of reason for that one, but why are recursive functions so important? The short answer is, because of Immutability! To understand the connection between those, let&amp;rsquo;s start with some code that uses loops with mutation.</description>
    </item>
    
    <item>
      <title>Understanding bind</title>
      <link>https://davidraab.github.io/posts/understanding-bind/</link>
      <pubDate>Sun, 03 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/understanding-bind/</guid>
      <description>In Understanding map we learned that implementing a map function is what we call a Functor. In Applicative Functors we extended that idea with the return and apply function and we call the result an Applicative Functor. The next important function in our toolset is the bind function.
Monads The combination of return and bind is what we call a Monad. But currently I will not consider this as an introduction to Monads at all.</description>
    </item>
    
    <item>
      <title>Applicative Functors</title>
      <link>https://davidraab.github.io/posts/applicative-functors/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applicative-functors/</guid>
      <description>In my previous article Understanding map I introduced the map function and described that implementing map and fulfilling two laws we get what we call a Functor. In this Post we discuss the apply function that we can view as an extension to the map function.
Problem with map It might be that you have noticed one problem with map. map only can work with one-argument functions! The definition of map expects a function &#39;a -&amp;gt; &#39;b as it&amp;rsquo;s first argument.</description>
    </item>
    
    <item>
      <title>Understanding map</title>
      <link>https://davidraab.github.io/posts/understanding-map/</link>
      <pubDate>Sun, 27 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/understanding-map/</guid>
      <description>One important function in functional programming is the map function. When I learned F# I must admit that I had some problems first, understanding it. The problem was, I already knew the map function from dozens of other languages. Or to say it correctly, I mostly learned a wrong explanation of map.
The typical explanation I&amp;rsquo;m talking about often goes something like this: map takes a function and a list. It applies the function to every element in the list, and returns a new list.</description>
    </item>
    
    <item>
      <title>Exceptions are Evil</title>
      <link>https://davidraab.github.io/posts/exceptions-are-evil/</link>
      <pubDate>Fri, 25 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/exceptions-are-evil/</guid>
      <description>Most people today agree that null is evil, and they try to get rid of them. One technique that most people prefer is to throw an exception in the case of an error, or if we cannot return a valid value from a function. The problem is, exceptions are not any kind better than null, and they don&amp;rsquo;t solve any problem that null introduced.
In my previous post null is Evil i mentioned seven problems that null introduced.</description>
    </item>
    
    <item>
      <title>Higher-kinded Polymorphism: What is it, why you want it</title>
      <link>https://davidraab.github.io/posts/higher-kinded-polymorphism/</link>
      <pubDate>Thu, 24 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/higher-kinded-polymorphism/</guid>
      <description>One aspect of a programming language that is often noted as important is the idea of Polymorphism. But there doesn&amp;rsquo;t exists just one type of polymorphism. In functional languages Parametric Polymorphism (aka Generics) is often used. Haskell was the first language that introduced &amp;ldquo;Higher-kinded polymorphism&amp;rdquo;. Sadly, F# don&amp;rsquo;t support this kind of polymorphism directly. Actually it only has partial support for it. So let&amp;rsquo;s look in what it is, and why you want it.</description>
    </item>
    
    <item>
      <title>null is Evil</title>
      <link>https://davidraab.github.io/posts/null-is-evil/</link>
      <pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/null-is-evil/</guid>
      <description>Tony Hoare once said: I call it my billion-dollar mistake. It was the invention of the null reference in 1965. So, why did he added &amp;ldquo;null&amp;rdquo; in the first place? Why was it such a big mistake. And if it is such a big mistake, what are the alternatives?
The purpose of null To understand why it was a mistake, let&amp;rsquo;s look why it was even added in the first place.</description>
    </item>
    
    <item>
      <title>Understanding Immutability and Pure Functions (for OOP)</title>
      <link>https://davidraab.github.io/posts/immutability-and-functions/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/immutability-and-functions/</guid>
      <description>One important concept in functional programming is immutability. But also in object-oriented programming immutability and so called immutable objects getting more attention. The problem that I see especially from object-oriented programmers are really bad explanations. A lot of explanation I had see described it like this: Just create a class and make all fields readonly (final or const) and you have an immutable object.
Explanations like these are horrible. Such explanations are so simplified that I would even call them wrong.</description>
    </item>
    
    <item>
      <title>Introduction to F#</title>
      <link>https://davidraab.github.io/posts/introduction-fsharp/</link>
      <pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/introduction-fsharp/</guid>
      <description>When I remember the first time I looked at functional(-first) languages like F#, ML, Haskell and others. The typical reaction that I had, and I always see from other people is: This is unreadable, it must be hard to read, it feels complicated and hard.
After spending some time in F# I cannot agree to that at all anymore. Often the syntax itself is easier (for example compared to C#), shorter and in my opinion more readable.</description>
    </item>
    
    <item>
      <title>Applying Structured Programming</title>
      <link>https://davidraab.github.io/posts/applying-structured-programming/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/applying-structured-programming/</guid>
      <description>In my previous post about Structured Programming I talked about that basic looping constructs fold. But this is still to powerful. In the sense of readability we should try to eliminate them with more specific ones. In this post I go through a toy example to show the various ways on how to refactor some code.
The Toy Example Recently I had some conversation about code in a game and providing some kind of critical hit-chance in a game.</description>
    </item>
    
    <item>
      <title>Structured Programming</title>
      <link>https://davidraab.github.io/posts/structured-programming/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://davidraab.github.io/posts/structured-programming/</guid>
      <description>Back in 1968 Edsger W. Dijkstra wrote an open letter named &amp;ldquo;Go To Statement Considered Harmful&amp;rdquo;. As already suggested from the title, the very idea was to raise consciousness that the goto statement is more harmful then helpful. From today view we would expect that this idea catches fire really fast, but it didn&amp;rsquo;t. It took quite a long time. Even during all the 1970s and 1980s that question was debated a lot.</description>
    </item>
    
  </channel>
</rss>
